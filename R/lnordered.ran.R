# Log-likelihood of ordered model with random parameters

lnordered.ran<-function(theta, y, X, ranp, R, correlation, link,
                        weights = NULL, haltons = NULL,
                        seed = 123, make.estb = FALSE,
                        ... )
{
  pfun <- switch(link,
                 "ordered probit" = pnorm,
                 "ordered logit"  = plogis)
  dfun <- switch(link,
                 "ordered probit" = dnorm,
                 "ordered logit"  = dlogis)
  #Get Variables and Global Parameters
  N    <- nrow(X)
  K    <- ncol(X)
  Vara <- sort(match(names(ranp), colnames(X)))
  Varc <- (1:K)[- Vara]
  Ka   <- length(Vara)
  Kc   <- length(Varc)
  Xa   <- X[, Vara, drop = F]                        
  Xc   <- X[, Varc, drop = F] 
  
  #For gradient
  m       <- unclass(sort(unique(y)))
  J       <- length(levels(y))
  m       <- as.matrix(m[2:(J - 1)], nrow = (J - 2))               
  y       <- unclass(y)
  delta   <- t(kronecker(m, t(rep(1, nrow(X)))))    
  deltaj  <- delta == y
  deltak  <- delta == y-1
  
  #Get estimated coefficients
  alpha    <- theta[1:(J - 2)]
  kappa    <- c(-Inf, cumsum(c(0, exp(alpha))), +Inf)
  gamma    <- as.matrix(theta[((J - 2) + 1):((J - 2) + Kc)])
  betasr   <- theta[-c(1:((J - 2) + Kc))]
  beta.bar <- as.matrix(betasr[c(1:Ka)])  
  sigma    <- betasr[-c(1:Ka)]            
  
  #Make Random Draws
  set.seed(seed)
  Omega <- make.draws(R * N, Ka, haltons) #Ka * N*R
  
  #Fixed part of index
  ZB    <- as.vector(crossprod(t(Xc), gamma)) #N*1
  
  #Random Part of index
  XB    <- matrix(NA, N, R)  #N*R
  #Matrix for Est.E(b_i)
  Br    <- array(NA, dim = c(N, R, Ka))
  for (i in 1:N){
    omega    <-Omega[, ((i - 1) * R + 1):(i * R) , drop = FALSE] #Ka*R for individual i
    beta.r   <-Make.rcoef(beta = beta.bar, sigma = sigma, ranp = ranp, omega = omega, 
                          correlation = correlation, Pi = NULL, S = NULL)
    XB[i, ]  <-crossprod(t(Xa[i, , drop = FALSE]), beta.r$br)
    Br[i, , ] <-t(beta.r$br) #Now is R*Ka
  }
  
  #Get probability
  index    <- ZB + XB
  eta1     <- kappa[y + 1] - index
  eta2     <- kappa[y]   - index
  Pir      <- pfun(eta1) - pfun(eta2)
  Pir      <- ifelse(Pir <= 0, .Machine$double.eps, Pir)
  Pi       <- apply(Pir, 1, mean)
  lls      <- sum(weights * log(Pi)) 
  
  #Gradient
  phi1     <- dfun(eta1) ; phi2 <- dfun(eta2)
  lambda   <- (phi2 - phi1) / Pir
  Qir      <- Pir / (Pi * R)
  eta      <- Qir * lambda
  
  #Kappa part
  gkappa   <- vector(mode = "list", length = (J - 2))
  for (j in 1:(J - 2)){
    gkappa[[j]] <- matrix(NA, N, R)
    gkappa[[j]] <- drop(deltaj[ , j]) * (phi1 / Pir) - drop(deltak[ ,j]) * (phi2 / Pir)
  }
  gkappa <- lapply(gkappa, function(x) x * Qir)
  gkappa <- lapply(gkappa, function(x) apply(x, 1, sum))
  gkappa <- Reduce(cbind, gkappa) %*% jacobian(alpha)
  
  
  dUdb <- matrix(NA, N, Ka)
  if(correlation){
    dUds <- matrix(NA, N, (0.5 * Ka * (Ka + 1))) 
  }else{
    dUds <- matrix(NA, N, Ka)  
  }
  for(i in 1:N){
    omega     <- Omega[ , ((i - 1) * R + 1):(i * R) , drop = FALSE]
    beta.r    <- Make.rcoef(beta = beta.bar, sigma = sigma, ranp = ranp, omega = omega, 
                            correlation = correlation, Pi = NULL, S = NULL)
    dUdb[i, ] <- tcrossprod(eta[i, ], beta.r$d.mu)  
    dUds[i, ] <- tcrossprod(eta[i, ], beta.r$d.sigma)
  }
  
  if(correlation){
    vecX <- c()
    for (i in 1:Ka){
      vecX <- c(vecX, i:Ka)
    }
    Xac <- Xa[ ,vecX]
  }else{
    Xac <- Xa  
  }
  
  gbarfi <- Xc  * as.vector(apply(Qir * lambda, 1, sum))
  gbarmi <- Xa  * dUdb
  gbarvi <- Xac * dUds
  
  gbari  <- cbind(gkappa, gbarfi , gbarmi , gbarvi)
  attr(lls, 'gradient') <- weights * gbari
  
  if (make.estb){
    b.ran  <- array(NA, dim = c(N, R, Ka))
    b.ran2 <- array(NA, dim = c(N, R, Ka))
    for(j in 1:Ka){
      b.ran[, , j]  < Br[, , j] * Qir
      b.ran2[, , j] <- (Br[, , j]^2) * Qir
    }
    b.ran  <- apply(b.ran,  c(1,3), sum)
    b.ran2 <- apply(b.ran2, c(1,3), sum)
    colnames(b.ran) <- colnames(Xa)
    
    sd.ran <- sqrt(b.ran2 - b.ran^2)
    colnames(sd.ran) <- colnames(Xa)
    attr(lls,'b.random') <- b.ran
    attr(lls,'sd.random') <- sd.ran
    attr(lls,'probabilities') <- Pi
  } 
  lls
}
